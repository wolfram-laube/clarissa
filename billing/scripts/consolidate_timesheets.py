#!/usr/bin/env python3
"""
BLAUWEISS EDV LLC - Timesheet Consolidation

Merges individual contractor timesheets into a consolidated team timesheet
for client delivery. Hides individual rates - shows only total hours.

Input:
    Individual contractor timesheets (PDF or Typst source)
    
Output:
    Consolidated team timesheet (PDF)

Usage:
    python consolidate_timesheets.py --client nemensis --month 2026-01 \
        wolfram_timesheet.pdf ian_timesheet.pdf -o consolidated.pdf
    
    python consolidate_timesheets.py --client nemensis --month 2026-01 \
        --input-dir billing/output/ -o billing/output/nemensis_2026-01_timesheet.pdf

Note:
    This script creates a summary view. For full PDF merging with preserved
    formatting, consider using pypdf or Typst templates.
"""

import argparse
import json
import os
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass, field


@dataclass
class TimesheetEntry:
    """Single timesheet entry."""
    date: str
    hours: float
    description: str = ""


@dataclass
class ContractorTimesheet:
    """Individual contractor's timesheet data."""
    person: str
    client: str
    year: str
    month: str
    entries: List[TimesheetEntry] = field(default_factory=list)
    total_hours: float = 0.0


@dataclass
class ConsolidatedTimesheet:
    """Merged team timesheet."""
    client: str
    year: str
    month: str
    contractors: List[str] = field(default_factory=list)
    daily_hours: Dict[str, float] = field(default_factory=dict)  # date -> total hours
    total_hours: float = 0.0


def parse_timesheet_filename(filename: str) -> Optional[Dict]:
    """Extract metadata from timesheet filename."""
    name = Path(filename).stem.lower()
    
    # Pattern: {person}_{client}_{year}-{month}_timesheet
    match = re.match(r'^([a-z]+)_([a-z0-9_]+)_(\d{4})-(\d{2})_timesheet$', name)
    if match:
        person, client, year, month = match.groups()
        return {
            'person': person,
            'client': client,
            'year': year,
            'month': month
        }
    
    # Legacy: {year}-{month}_timesheet_{client}_{person}_{lang}
    match = re.match(r'^(\d{4})-(\d{2})_timesheet_([a-z0-9_]+)_([a-z]+)_[a-z]{2}$', name)
    if match:
        year, month, client, person = match.groups()
        return {
            'person': person,
            'client': client,
            'year': year,
            'month': month
        }
    
    return None


def generate_consolidated_typst(consolidated: ConsolidatedTimesheet, output_path: Path) -> str:
    """Generate Typst source for consolidated timesheet."""
    
    # Sort dates
    sorted_dates = sorted(consolidated.daily_hours.keys())
    
    # Group by week
    weeks: Dict[int, List[tuple]] = {}
    for date_str in sorted_dates:
        date = datetime.strptime(date_str, "%Y-%m-%d")
        week_num = date.isocalendar()[1]
        if week_num not in weeks:
            weeks[week_num] = []
        weeks[week_num].append((date_str, consolidated.daily_hours[date_str]))
    
    # Build Typst content
    month_name = datetime.strptime(f"{consolidated.year}-{consolidated.month}-01", "%Y-%m-%d").strftime("%B %Y")
    
    typst_content = f'''#set page(margin: 2cm)
#set text(font: "Poppins", size: 10pt)

#align(center)[
  #text(size: 18pt, weight: "bold")[Team Timesheet]
  
  #text(size: 14pt)[{consolidated.client.title()} - {month_name}]
]

#v(1cm)

#table(
  columns: (1fr, 1fr, 1fr),
  inset: 8pt,
  align: (left, center, right),
  [*Client*], [*Period*], [*Total Hours*],
  [{consolidated.client.title()}], [{month_name}], [*{consolidated.total_hours:.1f}h*],
)

#v(0.5cm)

#text(size: 11pt, weight: "bold")[Team Members: {', '.join(c.title() for c in sorted(consolidated.contractors))}]

#v(1cm)

== Daily Breakdown

#table(
  columns: (auto, auto, auto),
  inset: 6pt,
  align: (left, right, left),
  [*Date*], [*Hours*], [*Day*],
'''
    
    for date_str in sorted_dates:
        hours = consolidated.daily_hours[date_str]
        date = datetime.strptime(date_str, "%Y-%m-%d")
        day_name = date.strftime("%A")
        typst_content += f'  [{date_str}], [{hours:.1f}h], [{day_name}],\n'
    
    typst_content += f''')

#v(0.5cm)

#align(right)[
  #text(size: 12pt, weight: "bold")[Total: {consolidated.total_hours:.1f} hours]
]

#v(2cm)

#line(length: 50%)
#text(size: 8pt, style: "italic")[
  Generated by BLAUWEISS EDV LLC Billing System \\
  {datetime.now().strftime("%Y-%m-%d %H:%M")}
]
'''
    
    return typst_content


def compile_typst(typst_source: str, output_pdf: Path) -> bool:
    """Compile Typst source to PDF."""
    # Write temp file
    temp_typ = output_pdf.with_suffix('.typ')
    temp_typ.write_text(typst_source)
    
    try:
        result = subprocess.run(
            ['typst', 'compile', str(temp_typ), str(output_pdf)],
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            print(f"  ‚úÖ Generated: {output_pdf.name}")
            return True
        else:
            print(f"  ‚ùå Typst error: {result.stderr}")
            return False
    except FileNotFoundError:
        print("  ‚ùå Typst not found. Please install: https://typst.app")
        return False
    finally:
        # Keep .typ for debugging, or remove:
        # temp_typ.unlink(missing_ok=True)
        pass


def main():
    parser = argparse.ArgumentParser(
        description="Consolidate contractor timesheets for client delivery",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("files", nargs="*", help="Individual timesheet PDFs")
    parser.add_argument("--client", "-c", required=True, help="Client name")
    parser.add_argument("--month", "-m", required=True, help="Month (YYYY-MM)")
    parser.add_argument("--input-dir", "-i", help="Directory with timesheet files")
    parser.add_argument("--output", "-o", required=True, help="Output PDF path")
    parser.add_argument("--hours-json", help="JSON file with hours data (alternative to PDFs)")
    
    args = parser.parse_args()
    
    # Parse month
    try:
        year, month = args.month.split('-')
    except ValueError:
        print(f"‚ùå Invalid month format: {args.month} (expected YYYY-MM)")
        sys.exit(1)
    
    print(f"üìä Consolidating timesheets for {args.client} - {args.month}")
    
    consolidated = ConsolidatedTimesheet(
        client=args.client.lower(),
        year=year,
        month=month
    )
    
    # Option 1: Load from JSON (structured data)
    if args.hours_json:
        with open(args.hours_json) as f:
            data = json.load(f)
        
        for person, hours_data in data.items():
            consolidated.contractors.append(person)
            for date_str, hours in hours_data.items():
                if date_str in consolidated.daily_hours:
                    consolidated.daily_hours[date_str] += hours
                else:
                    consolidated.daily_hours[date_str] = hours
                consolidated.total_hours += hours
        
        print(f"  üìÑ Loaded from JSON: {len(consolidated.contractors)} contractors")
    
    # Option 2: Collect files
    else:
        files = list(args.files) if args.files else []
        
        if args.input_dir:
            input_path = Path(args.input_dir)
            pattern = f"*_{args.client}_{args.month}_timesheet*.pdf"
            files.extend(str(f) for f in input_path.glob(pattern))
        
        if not files:
            print(f"‚ùå No timesheet files found")
            print(f"   Looking for pattern: *_{args.client}_{args.month}_timesheet*.pdf")
            sys.exit(1)
        
        print(f"  üìÑ Found {len(files)} timesheet files")
        
        # For now, we'll create a placeholder
        # In production, you'd extract hours from PDFs using pdf libraries
        for f in files:
            meta = parse_timesheet_filename(f)
            if meta and meta['person'] not in consolidated.contractors:
                consolidated.contractors.append(meta['person'])
                print(f"     + {meta['person']}")
        
        # Placeholder: Generate sample data
        # In production, extract actual hours from PDF content
        print("\n  ‚ö†Ô∏è Note: PDF extraction not implemented.")
        print("     Using placeholder data. For production, either:")
        print("     1. Use --hours-json with structured data")
        print("     2. Implement PDF text extraction")
        
        # Sample placeholder data
        import calendar
        _, days_in_month = calendar.monthrange(int(year), int(month))
        
        for day in range(1, days_in_month + 1):
            date = datetime(int(year), int(month), day)
            if date.weekday() < 5:  # Weekdays only
                # Placeholder: 8h per contractor per day
                hours = 8.0 * len(consolidated.contractors)
                date_str = date.strftime("%Y-%m-%d")
                consolidated.daily_hours[date_str] = hours
                consolidated.total_hours += hours
    
    print(f"\n  üë• Contractors: {', '.join(consolidated.contractors)}")
    print(f"  ‚è±Ô∏è  Total hours: {consolidated.total_hours:.1f}h")
    
    # Generate output
    output_path = Path(args.output)
    
    print(f"\nüìù Generating consolidated timesheet...")
    typst_source = generate_consolidated_typst(consolidated, output_path)
    
    if compile_typst(typst_source, output_path):
        print(f"\n‚úÖ Done: {output_path}")
    else:
        # Fallback: save Typst source
        typ_path = output_path.with_suffix('.typ')
        typ_path.write_text(typst_source)
        print(f"\n‚ö†Ô∏è Saved Typst source: {typ_path}")
        print("   Compile manually: typst compile {typ_path}")


if __name__ == "__main__":
    main()
