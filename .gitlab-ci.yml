workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      when: always
    # Trigger on semantic version tags (v1.0.0, v2.1.3, etc.)
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: always
    # Allow manual trigger via "Run pipeline" button
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: always
    - when: never

stages:
  - build
  - test
  - classify
  - automation
  - deploy

# ----------------------------
# Anchors (infrastructure hygiene)
# ----------------------------
.python_base: &python_base
  image: python:3.11
  variables:
    PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  cache:
    key: pip-cache
    paths:
      - .cache/pip

.install_dev_deps: &install_dev_deps
  before_script:
    - python -V
    - python -m pip install --upgrade pip
    - python -m pip install -e ".[dev]"

.pytest_run: &pytest_run
  script:
    - python -m pytest -q --junitxml=junit.xml
  artifacts:
    when: always
    reports:
      junit: junit.xml
    paths:
      - junit.xml
      - .pytest_cache/

.rerun_rules: &rerun_rules
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_failure
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      when: on_failure
    - when: never

.issue_bot_rules: &issue_bot_rules
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      when: on_success
    - when: never

.recovery_bot_rules: &recovery_bot_rules
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      when: on_success
    - when: never

.mr_bot_rules: &mr_bot_rules
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - when: never

# ----------------------------
# Build Stage - Docker Images
# ----------------------------
build_opm_image:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    IMAGE_BASE: $CI_REGISTRY_IMAGE/opm-flow
  before_script:
    - docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    - |
      echo "Building OPM Flow image..."
      
      # Always tag with commit SHA for traceability
      docker build -t $IMAGE_BASE:$CI_COMMIT_SHORT_SHA -f src/clarissa/simulators/opm/Dockerfile src/clarissa/simulators/opm/
      
      # Tag strategy based on context (ADR-012)
      if [ -n "$CI_COMMIT_TAG" ]; then
        # Release: semantic version tag (e.g., v1.2.3)
        echo "Release build: tagging as $CI_COMMIT_TAG"
        docker tag $IMAGE_BASE:$CI_COMMIT_SHORT_SHA $IMAGE_BASE:$CI_COMMIT_TAG
        docker tag $IMAGE_BASE:$CI_COMMIT_SHORT_SHA $IMAGE_BASE:latest
        
        # Push all tags
        docker push $IMAGE_BASE:$CI_COMMIT_SHORT_SHA
        docker push $IMAGE_BASE:$CI_COMMIT_TAG
        docker push $IMAGE_BASE:latest
        
        echo "IMAGE_TAG=$IMAGE_BASE:$CI_COMMIT_TAG" >> build.env
      else
        # Development: SHA + latest
        echo "Development build: tagging as $CI_COMMIT_SHORT_SHA and latest"
        docker tag $IMAGE_BASE:$CI_COMMIT_SHORT_SHA $IMAGE_BASE:latest
        
        docker push $IMAGE_BASE:$CI_COMMIT_SHORT_SHA
        docker push $IMAGE_BASE:latest
        
        echo "IMAGE_TAG=$IMAGE_BASE:$CI_COMMIT_SHORT_SHA" >> build.env
      fi
      
      echo "IMAGE_LATEST=$IMAGE_BASE:latest" >> build.env
  artifacts:
    reports:
      dotenv: build.env
  rules:
    # Build on MRs if OPM files changed
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - src/clarissa/simulators/opm/**/*
        - Dockerfile*
      when: on_success
    # Build on main if OPM files changed
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      changes:
        - src/clarissa/simulators/opm/**/*
        - Dockerfile*
      when: on_success
    # Always build on version tags (releases)
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: always
    # Manual trigger always available
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
      allow_failure: true
    - when: never

# ----------------------------
# Test Stage
# ----------------------------
tests:
  stage: test
  <<: *python_base
  <<: *install_dev_deps
  script:
    - python -m pytest -q --ignore=tests/integration --junitxml=junit.xml
  artifacts:
    when: always
    reports:
      junit: junit.xml
    paths:
      - junit.xml
      - .pytest_cache/
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
    - when: never

integration_tests_opm:
  stage: test
  image: docker:24
  services:
    - docker:24-dind
  needs:
    - job: build_opm_image
      artifacts: true
      optional: true
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  before_script:
    - apk add --no-cache python3 py3-pip
    - python3 -m pip install --break-system-packages -e ".[dev]"
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - |
      # Pull the image we just built, or try latest
      if [ -n "$IMAGE_TAG" ]; then
        docker pull $IMAGE_TAG && docker tag $IMAGE_TAG opm-flow:latest
      else
        docker pull $CI_REGISTRY_IMAGE/opm-flow:latest && docker tag $CI_REGISTRY_IMAGE/opm-flow:latest opm-flow:latest || echo "No image available, tests will skip"
      fi
  script:
    - |
      # Register custom pytest marker to avoid warnings
      echo "[pytest]" > pytest.ini
      echo "markers = docker: marks tests as requiring docker" >> pytest.ini
      python3 -m pytest -v tests/integration/test_opm_flow.py --junitxml=junit_integration.xml || true
  artifacts:
    when: always
    reports:
      junit: junit_integration.xml
    paths:
      - junit_integration.xml
  rules:
    # Only run when OPM-related files change
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - src/clarissa/simulators/opm/**/*
        - tests/integration/test_opm_flow.py
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      changes:
        - src/clarissa/simulators/opm/**/*
        - tests/integration/test_opm_flow.py
      when: on_success
    # Always run on version tags
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: on_success
    - when: never
  allow_failure: true

snapshot_tests:
  stage: test
  <<: *python_base
  <<: *install_dev_deps
  script:
    - |
      set -e
      mkdir -p tests/golden tests/golden/snapshots tests/golden/diffs

      echo '# Snapshot diffs' > tests/golden/summary.md
      echo '' >> tests/golden/summary.md
      echo '_No snapshot diffs produced._' >> tests/golden/summary.md
      echo '' >> tests/golden/summary.md

      python -m pytest -q \
        tests/golden/test_cli_help_snapshot.py \
        tests/golden/test_cli_demo_snapshot.py || EXIT=$?

      if [ -d tests/golden/diffs ] && ls -1 tests/golden/diffs/*.diff >/dev/null 2>&1; then
        echo '# Snapshot diffs' > tests/golden/summary.md
        echo '' >> tests/golden/summary.md
        for f in tests/golden/diffs/*.diff; do
          echo "## $(basename "$f")" >> tests/golden/summary.md
          echo '```diff' >> tests/golden/summary.md
          cat "$f" >> tests/golden/summary.md
          echo '```' >> tests/golden/summary.md
          echo '' >> tests/golden/summary.md
        done
      fi

      if [ -n "${EXIT:-}" ]; then exit "$EXIT"; fi
  artifacts:
    when: on_failure
    paths:
      - tests/golden/snapshots/
      - tests/golden/summary.md
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
    - when: never

contract_tests:
  stage: test
  <<: *python_base
  <<: *install_dev_deps
  script:
    - |
      set -e
      mkdir -p tests/contracts
      python -m pytest -q tests/contracts 2>&1 | tee pytest_contracts.log || EXIT=$?
      python scripts/generate_contract_summary.py || true
      if [ -n "${EXIT:-}" ]; then exit "$EXIT"; fi
  artifacts:
    when: on_failure
    paths:
      - tests/contracts/summary.md
      - pytest_contracts.log
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
    - when: never

governance_impact:
  stage: test
  <<: *python_base
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - when: never
  script:
    - mkdir -p tests/governance
    - python scripts/detect_governance_impact.py
  artifacts:
    when: always
    paths:
      - tests/governance/impact.md

architecture_graphs:
  stage: test
  image:
    name: ghcr.io/mermaid-js/mermaid-cli/mermaid-cli:latest
    entrypoint: [""]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      when: on_success
    - when: never
  script:
    - mkdir -p docs/architecture/diagrams docs/architecture/rendered
    - mmdc --version || true
    - bash scripts/render_mermaid.sh || echo "Mermaid render failed; keeping sources."
  artifacts:
    when: always
    paths:
      - docs/architecture/diagrams/
      - docs/architecture/rendered/
  allow_failure: true


mkdocs_nav_check:
  stage: test
  image: python:3.11-slim
  script:
    - pip install pyyaml -q
    - python scripts/check_mkdocs_nav.py
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
    - when: never

tests_rerun:
  stage: test
  <<: *python_base
  <<: *install_dev_deps
  <<: *rerun_rules
  needs:
    - job: tests
      artifacts: true
      optional: true
  script:
    - |
      set +e
      python -m pytest -q \
        --last-failed \
        --last-failed-no-failures=none \
        --maxfail=${CI_BOT_RERUN_MAXFAIL:-1} \
        -x \
        --junitxml=junit_rerun.xml
      echo $? > rerun_exit_code.txt
      exit 0
  artifacts:
    when: always
    paths:
      - junit_rerun.xml
      - rerun_exit_code.txt

# ----------------------------
# Classify Stage
# ----------------------------
ci_classify:
  stage: classify
  <<: *python_base
  needs:
    - job: tests
      artifacts: true
      optional: true
    - job: tests_rerun
      artifacts: true
      optional: true
  script:
    - python scripts/ci_classify.py
  artifacts:
    reports:
      dotenv: ci_classify.env
    paths:
      - ci_classify.env
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
    - when: never

# ----------------------------
# Automation Stage
# ----------------------------
mr_report:
  stage: automation
  <<: *python_base
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - when: never
  needs:
    - job: snapshot_tests
      artifacts: true
      optional: true
    - job: contract_tests
      artifacts: true
      optional: true
    - job: governance_impact
      artifacts: true
      optional: true
    - job: architecture_graphs
      artifacts: true
      optional: true
    - job: integration_tests_opm
      artifacts: true
      optional: true
  script:
    - mkdir -p reports
    - python scripts/generate_mr_report.py
    - python scripts/render_report_html.py || true
  artifacts:
    when: always
    paths:
      - reports/mr_report.md
      - reports/mr_report.html

ci_flaky_ledger:
  stage: automation
  <<: *python_base
  <<: *issue_bot_rules
  needs:
    - job: ci_classify
      artifacts: true
      optional: true
  script:
    - python scripts/gitlab_flaky_ledger_bot.py

ci_issue_on_failure:
  stage: automation
  <<: *python_base
  <<: *issue_bot_rules
  needs:
    - job: ci_classify
      artifacts: true
      optional: true
  script:
    - python scripts/gitlab_issue_bot.py

ci_issue_on_recovery:
  stage: automation
  <<: *python_base
  <<: *recovery_bot_rules
  needs:
    - job: ci_classify
      artifacts: true
      optional: true
  script:
    - python scripts/gitlab_recovery_bot.py

mr_comment_on_failure:
  stage: automation
  <<: *python_base
  <<: *mr_bot_rules
  needs:
    - job: ci_classify
      artifacts: true
      optional: true
  script:
    - python scripts/gitlab_mr_bot.py

# ----------------------------
# Deploy Stage
# ----------------------------
pages:
  stage: deploy
  image: python:3.11
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      when: on_success
    - when: never
  before_script:
    - pip install mkdocs mkdocs-material pymdown-extensions jinja2 pyyaml
  script:
    # Build i18n docs from templates
    - python scripts/build_i18n_docs.py
    # Build MkDocs site from docs/ directory
    - mkdocs build --site-dir public
    # Copy static HTML files that MkDocs doesn't process (reveal.js slides, etc.)
    - |
      echo "Copying static HTML files..."
      mkdir -p public/guides/contributing
      cp docs/guides/contributing/*.html public/guides/contributing/ 2>/dev/null || echo "No HTML files to copy"
      ls -la public/guides/contributing/ 2>/dev/null || true
  artifacts:
    paths:
      - public
    expire_in: 1 week

llm_sync_package:
  stage: deploy
  image: python:3.11
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "push"'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
      allow_failure: true
    - when: never
  script:
    - |
      BRANCH="${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME:-${CI_COMMIT_BRANCH:-${CI_COMMIT_TAG:-main}}}"
      echo "Generating sync package for branch: $BRANCH"
      cd scripts
      python llm_sync_generator.py --branch "$BRANCH" --lite -o ../clarissa_sync_lite.md
      python llm_sync_generator.py --branch "$BRANCH" --medium -o ../clarissa_sync_medium.md
      python llm_sync_generator.py --branch "$BRANCH" --lite --since ${CI_COMMIT_BEFORE_SHA:-HEAD~5} -o ../clarissa_sync_diff.md || true
  artifacts:
    paths:
      - clarissa_sync_lite.md
      - clarissa_sync_medium.md
      - clarissa_sync_diff.md
    expire_in: 4 weeks

# ----------------------------
# Manual Trigger Jobs
# ----------------------------
# These jobs can be triggered via:
#   1. GitLab UI: CI/CD → Pipelines → Run Pipeline → Select job
#   2. API: POST /projects/:id/pipeline with variables

rebuild_docs:
  stage: deploy
  image: python:3.11
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
    - when: never
  before_script:
    - pip install mkdocs mkdocs-material pymdown-extensions jinja2 pyyaml
  script:
    - echo "Rebuilding documentation..."
    - python scripts/build_i18n_docs.py
    - mkdocs build --site-dir public
    - |
      mkdir -p public/guides/contributing
      cp docs/guides/contributing/*.html public/guides/contributing/ 2>/dev/null || true
  artifacts:
    paths:
      - public
    expire_in: 1 day
  environment:
    name: docs-preview
    url: https://wolfram_laube.gitlab.io/blauweiss_llc/irena/

rebuild_opm_image:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
    - when: never
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    IMAGE_BASE: $CI_REGISTRY_IMAGE/opm-flow
  before_script:
    - docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    - |
      echo "Manual rebuild of OPM Flow image..."
      docker build --no-cache -t $IMAGE_BASE:$CI_COMMIT_SHORT_SHA -f src/clarissa/simulators/opm/Dockerfile src/clarissa/simulators/opm/
      docker tag $IMAGE_BASE:$CI_COMMIT_SHORT_SHA $IMAGE_BASE:latest
      docker push $IMAGE_BASE:$CI_COMMIT_SHORT_SHA
      docker push $IMAGE_BASE:latest
      echo "✅ Pushed: $IMAGE_BASE:$CI_COMMIT_SHORT_SHA"
      echo "✅ Pushed: $IMAGE_BASE:latest"

rerun_all_tests:
  stage: test
  <<: *python_base
  <<: *install_dev_deps
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
    - when: never
  script:
    - echo "Running full test suite (manual trigger)..."
    - python -m pytest -v --junitxml=junit_manual.xml
  artifacts:
    when: always
    reports:
      junit: junit_manual.xml
    paths:
      - junit_manual.xml

build_paper:
  stage: build
  image: texlive/texlive:latest
  rules:
    # Auto-run when paper files change
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - conference/**/*
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      changes:
        - conference/**/*
      when: on_success
    # Manual trigger always available
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
    - when: never
  script:
    - cd conference/ijacsa-2026
    - echo "Building CLARISSA paper..."
    - pdflatex -interaction=nonstopmode CLARISSA_Paper_IJACSA.tex || true
    - pdflatex -interaction=nonstopmode CLARISSA_Paper_IJACSA.tex  # Second pass for references
    - echo "✅ Paper built successfully"
    - ls -la *.pdf
  artifacts:
    paths:
      - conference/ijacsa-2026/CLARISSA_Paper_IJACSA.pdf
    expire_in: 4 weeks

build_invoice:
  stage: build
  image: alpine:latest
  rules:
    # Auto-run when invoice templates change
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - billing/templates/**/*
        - billing/output/**/*.typ
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      changes:
        - billing/templates/**/*
        - billing/output/**/*.typ
      when: on_success
    # Manual trigger always available
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
    - when: never
  before_script:
    - apk add --no-cache curl tar xz fontconfig ttf-liberation
    # Install Poppins font
    - mkdir -p /usr/share/fonts/poppins
    - curl -L "https://github.com/google/fonts/raw/main/ofl/poppins/Poppins-Regular.ttf" -o /usr/share/fonts/poppins/Poppins-Regular.ttf
    - curl -L "https://github.com/google/fonts/raw/main/ofl/poppins/Poppins-Bold.ttf" -o /usr/share/fonts/poppins/Poppins-Bold.ttf
    - curl -L "https://github.com/google/fonts/raw/main/ofl/poppins/Poppins-Medium.ttf" -o /usr/share/fonts/poppins/Poppins-Medium.ttf
    - fc-cache -fv
    # Install Typst
    - curl -L "https://github.com/typst/typst/releases/download/v0.12.0/typst-x86_64-unknown-linux-musl.tar.xz" -o /tmp/typst.tar.xz
    - tar xf /tmp/typst.tar.xz -C /tmp
    - mv /tmp/typst-x86_64-unknown-linux-musl/typst /usr/local/bin/
    - typst --version
  script:
    - echo "Building invoices with Typst..."
    - cd billing/output
    - cp ../templates/logo.jpg . 2>/dev/null || true
    - |
      for f in *.typ; do
        if [ -f "$f" ]; then
          echo "Compiling $f..."
          typst compile "$f"
        fi
      done
    - echo "✅ Invoices built"
    - ls -la *.pdf 2>/dev/null || echo "No PDFs generated"
  artifacts:
    paths:
      - billing/output/*.pdf
    expire_in: 8 weeks

# Upload billing documents to Google Drive
upload_invoice:
  stage: deploy

# Upload billing documents to Google Drive
upload_invoice:
  stage: deploy
  image: python:3.11-slim
  needs:
    - job: build_invoice
      artifacts: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      changes:
        - billing/output/**/*.typ
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
      allow_failure: true
    - when: never
  script:
    - pip install google-auth google-api-python-client -q
    - python billing/scripts/upload_to_drive.py billing/output/*.pdf
