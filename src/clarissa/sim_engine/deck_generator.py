"""Eclipse Deck Generator — GridParams + WellConfig → Eclipse .DATA deck.

Generates Eclipse-format simulation decks that OPM Flow can run directly.
Supports:
- Cartesian grids with uniform or layered properties
- Injector/Producer well pairs
- Two-phase (oil-water) and three-phase (oil-water-gas) models
- Configurable PVT, relative permeability, and initial conditions

The generated decks use METRIC units internally, converting from SI inputs.

Issue #164 | Epic #161 | ADR-038
"""
from __future__ import annotations

import textwrap
from datetime import datetime, timezone
from typing import Optional

from .models import (
    GridParams,
    WellConfig,
    FluidProperties,
    SimRequest,
    WellType,
    Phase,
)


# ─── Unit Conversion Helpers ──────────────────────────────────────────────

def _m_to_ft(m: float) -> float:
    """Meters to feet."""
    return m * 3.28084


def _bar_to_psi(bar: float) -> float:
    """Bar to psi."""
    return bar * 14.5038


def _m3d_to_stbd(m3d: float) -> float:
    """m³/day to STB/day (stock tank barrels per day)."""
    return m3d * 6.28981


def _mD_to_mD(md: float) -> float:
    """milliDarcy — no conversion needed (already industry unit)."""
    return md


# ─── Deck Section Generators ─────────────────────────────────────────────

def _runspec_section(request: SimRequest) -> str:
    """Generate RUNSPEC section."""
    grid = request.grid
    n_wells = len(request.wells)

    # Determine phases from wells
    has_gas = any(Phase.GAS in w.phases for w in request.wells)
    has_water = any(Phase.WATER in w.phases for w in request.wells)

    phases = "OIL\n"
    if has_water or True:  # Always include water for simplicity
        phases += "WATER\n"
    if has_gas:
        phases += "GAS\nDISGAS\n"

    return textwrap.dedent(f"""\
        RUNSPEC
        -- Generated by CLARISSA Sim-Engine Deck Generator
        -- {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC

        TITLE
           {request.title}

        DIMENS
           {grid.nx} {grid.ny} {grid.nz} /

        EQLDIMS
        /

        TABDIMS
        /

        {phases}
        FIELD

        START
           1 'JAN' 2025 /

        WELLDIMS
           {max(n_wells, 2)} {grid.nz} 1 {max(n_wells, 2)} /

        UNIFIN
        UNIFOUT

    """)


def _grid_section(grid: GridParams) -> str:
    """Generate GRID section with constant or layered properties."""
    n_cells = grid.total_cells
    nx, ny, nz = grid.nx, grid.ny, grid.nz
    cells_per_layer = nx * ny

    # Convert to FIELD units (ft, mD)
    dx_ft = _m_to_ft(grid.dx)
    dy_ft = _m_to_ft(grid.dy)
    dz_ft = _m_to_ft(grid.dz)
    depth_ft = _m_to_ft(grid.depth_top)

    lines = [
        "GRID",
        "",
        "INIT",
        "",
        "DX",
        f"   {n_cells}*{dx_ft:.2f} /",
        "",
        "DY",
        f"   {n_cells}*{dy_ft:.2f} /",
        "",
        "DZ",
        f"   {n_cells}*{dz_ft:.2f} /",
        "",
        "TOPS",
        f"   {cells_per_layer}*{depth_ft:.2f} /",
        "",
        "PORO",
        f"   {n_cells}*{grid.porosity:.4f} /",
        "",
    ]

    # Permeability — uniform per layer for now
    # (layered/stochastic perm is a future enhancement)
    lines.extend([
        "PERMX",
        f"   {n_cells}*{grid.permeability_x:.2f} /",
        "",
        "PERMY",
        f"   {n_cells}*{grid.permeability_y:.2f} /",
        "",
        "PERMZ",
        f"   {n_cells}*{grid.permeability_z:.2f} /",
        "",
    ])

    return "\n".join(lines) + "\n"


def _props_section(fluid: FluidProperties) -> str:
    """Generate PROPS section with PVT and relperm tables.

    Uses simplified Corey-type relative permeability and constant PVT.
    """
    p_ref_psi = _bar_to_psi(fluid.initial_pressure_bar)

    return textwrap.dedent(f"""\
        PROPS

        PVTW
        -- Ref Pressure[psi]  FVF  Compressibility[1/psi]  Viscosity[cP]  Viscosibility
           {p_ref_psi:.1f}  1.01  3.0E-6  {fluid.water_viscosity_cp:.3f}  0.0 /

        ROCK
           14.7  3.0E-6 /

        SWOF
        -- Sw        krw            kro            Pcow
        0.12    0.0000         1.0000         0.0
        0.20    0.0001         0.8500         0.0
        0.30    0.0020         0.6000         0.0
        0.40    0.0100         0.3500         0.0
        0.50    0.0350         0.1500         0.0
        0.60    0.0800         0.0500         0.0
        0.70    0.1600         0.0100         0.0
        0.80    0.3000         0.0010         0.0
        0.88    0.5000         0.0000         0.0
        1.00    1.0000         0.0000         0.0 /

        DENSITY
        -- Oil[lb/ft³]  Water[lb/ft³]  Gas[lb/ft³]
           {fluid.oil_density_kg_m3 * 0.0624279:.2f}  {fluid.water_density_kg_m3 * 0.0624279:.2f}  0.0533 /

        PVDO
        -- P[psi]     Bo      Viscosity[cP]
           14.7       1.062   {fluid.oil_viscosity_cp * 1.04:.4f}
           {_bar_to_psi(fluid.bubble_point_bar):.1f}  1.150   {fluid.oil_viscosity_cp:.4f}
           {p_ref_psi:.1f}  1.100   {fluid.oil_viscosity_cp * 1.10:.4f}
           {p_ref_psi * 1.5:.1f}  1.060   {fluid.oil_viscosity_cp * 1.20:.4f} /

    """)


def _solution_section(grid: GridParams, fluid: FluidProperties) -> str:
    """Generate SOLUTION section with equilibrium data."""
    depth_ft = _m_to_ft(grid.depth_top)
    reservoir_bottom_ft = _m_to_ft(grid.depth_top + grid.nz * grid.dz)
    p_init_psi = _bar_to_psi(fluid.initial_pressure_bar)

    return textwrap.dedent(f"""\
        SOLUTION

        EQUIL
        -- Datum[ft]  P@datum[psi]  WOC[ft]  Pcow  GOC[ft]  Pcog
           {depth_ft:.1f}  {p_init_psi:.1f}  {reservoir_bottom_ft + 100:.1f}  0  {depth_ft - 100:.1f}  0  1  0  0 /

    """)


def _summary_section(wells: list[WellConfig]) -> str:
    """Generate SUMMARY section requesting key output vectors."""
    lines = [
        "SUMMARY",
        "",
        "-- Field totals",
        "FOPR",
        "FWPR",
        "FGOR",
        "FOPT",
        "FWPT",
        "",
    ]

    # Per-well data
    for w in wells:
        lines.extend([
            f"-- Well: {w.name}",
            "WOPR",
            f"   '{w.name}' /",
            "WWPR",
            f"   '{w.name}' /",
            "WBHP",
            f"   '{w.name}' /",
            "WWIR",
            f"   '{w.name}' /",
            "",
        ])

    # Block pressures at corners
    lines.extend([
        "-- Block data",
        "BPR",
        "1 1 1 /",
        "/",
        "",
    ])

    return "\n".join(lines) + "\n"


def _schedule_section(
    wells: list[WellConfig],
    grid: GridParams,
    timesteps_days: list[float],
) -> str:
    """Generate SCHEDULE section with well specs and timesteps."""
    lines = [
        "SCHEDULE",
        "",
        "RPTSCHED",
        "   'PRES' 'SWAT' 'WELLS' /",
        "",
        "RPTRST",
        "   'BASIC=1' /",
        "",
    ]

    # Well specifications
    lines.append("WELSPECS")
    for w in wells:
        # Convert 0-based to 1-based grid indices
        i1 = w.i + 1
        j1 = w.j + 1
        depth_ft = _m_to_ft(grid.depth_top + w.k_top * grid.dz + grid.dz / 2)
        phase_str = "OIL" if w.well_type == WellType.PRODUCER else "WATER"
        lines.append(f"   '{w.name}'  'G1'  {i1}  {j1}  {depth_ft:.1f}  '{phase_str}' /")
    lines.append("/")
    lines.append("")

    # Completion data
    lines.append("COMPDAT")
    for w in wells:
        i1 = w.i + 1
        j1 = w.j + 1
        k_top1 = w.k_top + 1
        k_bot1 = w.k_bottom + 1
        lines.append(
            f"   '{w.name}'  {i1}  {j1}  {k_top1}  {k_bot1}  'OPEN'  1*  1*  0.5 /"
        )
    lines.append("/")
    lines.append("")

    # Production/injection controls
    for w in wells:
        if w.well_type == WellType.PRODUCER:
            rate_stbd = _m3d_to_stbd(abs(w.rate_m3_day)) if w.rate_m3_day else 10000
            bhp_psi = _bar_to_psi(w.bhp_bar) if w.bhp_bar else 1000
            lines.extend([
                "WCONPROD",
                f"   '{w.name}'  'OPEN'  'ORAT'  {rate_stbd:.1f}  4*  {bhp_psi:.1f} /",
                "/",
                "",
            ])
        else:  # INJECTOR
            rate_stbd = _m3d_to_stbd(abs(w.rate_m3_day)) if w.rate_m3_day else 5000
            bhp_psi = _bar_to_psi(w.bhp_bar) if w.bhp_bar else 6000
            lines.extend([
                "WCONINJE",
                f"   '{w.name}'  'WATER'  'OPEN'  'RATE'  {rate_stbd:.1f}  1*  {bhp_psi:.1f} /",
                "/",
                "",
            ])

    # Timesteps
    lines.append("TSTEP")
    # Convert cumulative timesteps to incremental
    prev = 0.0
    increments = []
    for t in sorted(timesteps_days):
        dt = t - prev
        if dt > 0:
            increments.append(f"{dt:.1f}")
        prev = t

    # Format in rows of 6
    for i in range(0, len(increments), 6):
        chunk = increments[i : i + 6]
        lines.append("   " + " ".join(chunk))
    lines.append("/")
    lines.append("")
    lines.append("END")
    lines.append("")

    return "\n".join(lines)


# ─── Public API ───────────────────────────────────────────────────────────

def generate_deck(request: SimRequest) -> str:
    """Generate a complete Eclipse .DATA deck from a SimRequest.

    Args:
        request: Simulation request with grid, wells, fluid, timesteps.

    Returns:
        Complete Eclipse .DATA deck as a string.

    Example:
        >>> from clarissa.sim_engine.models import *
        >>> req = SimRequest(
        ...     grid=GridParams(nx=10, ny=10, nz=3),
        ...     wells=[
        ...         WellConfig(name="PROD", well_type=WellType.PRODUCER, i=9, j=9, bhp_bar=70),
        ...         WellConfig(name="INJ", well_type=WellType.INJECTOR, i=0, j=0, rate_m3_day=500),
        ...     ],
        ... )
        >>> deck = generate_deck(req)
        >>> assert "RUNSPEC" in deck
        >>> assert "PROD" in deck
    """
    sections = [
        _runspec_section(request),
        _grid_section(request.grid),
        _props_section(request.fluid),
        _solution_section(request.grid, request.fluid),
        _summary_section(request.wells),
        _schedule_section(request.wells, request.grid, request.timesteps_days),
    ]
    return "\n".join(sections)


def write_deck(request: SimRequest, path: str) -> str:
    """Generate and write Eclipse deck to file.

    Args:
        request: Simulation request.
        path: Output file path (should end in .DATA).

    Returns:
        The file path written to.
    """
    deck_str = generate_deck(request)
    with open(path, "w") as f:
        f.write(deck_str)
    return path
